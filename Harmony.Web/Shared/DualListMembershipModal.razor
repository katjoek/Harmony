@using Harmony.Web.Models
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="modal fade @(Show ? "show d-block" : "")" tabindex="-1" style="background-color: rgba(0,0,0,0.5)">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">@Title</h5>
                <button type="button" class="btn-close" @onclick="OnCloseClicked"></button>
            </div>
            <div class="modal-body">
                <div class="row">
                    <div class="col-md-5">
                        <label class="form-label">@LeftLabel</label>
                        <select id="@LeftSelectId" multiple size="10" class="form-select dual-list-select" @onchange="OnLeftChange">
                            @foreach (var item in LeftItems)
                            {
                                <option value="@item.Id">@item.Label</option>
                            }
                        </select>
                    </div>
                    <div class="col-md-2 d-flex flex-column justify-content-center align-items-center gap-2">
                        <button type="button" class="btn btn-outline-primary" title="Naar rechts" @onclick="MoveLeftSelectionToRight" disabled="@(IsBusy || !selectedLeftIds.Any())">
                            <i class="fas fa-arrow-right"></i>
                        </button>
                        <button type="button" class="btn btn-outline-primary" title="Naar links" @onclick="MoveRightSelectionToLeft" disabled="@(IsBusy || !selectedRightIds.Any())">
                            <i class="fas fa-arrow-left"></i>
                        </button>
                    </div>
                    <div class="col-md-5">
                        <label class="form-label">@RightLabel (@RightItems.Count)</label>
                        <select id="@RightSelectId" multiple size="10" class="form-select dual-list-select" @onchange="OnRightChange">
                            @foreach (var item in RightItems)
                            {
                                <option value="@item.Id">@item.Label</option>
                            }
                        </select>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" @onclick="OnCloseClicked">Sluiten</button>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter] public bool Show { get; set; }
    [Parameter] public string Title { get; set; } = string.Empty;
    [Parameter] public string LeftLabel { get; set; } = "Links";
    [Parameter] public string RightLabel { get; set; } = "Rechts";
    [Parameter] public string LeftSelectId { get; set; } = Guid.NewGuid().ToString("N");
    [Parameter] public string RightSelectId { get; set; } = Guid.NewGuid().ToString("N");
    [Parameter] public List<DualListItem> LeftItems { get; set; } = new();
    [Parameter] public List<DualListItem> RightItems { get; set; } = new();
    [Parameter] public bool IsBusy { get; set; }
    [Parameter] public EventCallback Close { get; set; }
    [Parameter] public EventCallback<IEnumerable<string>> MoveLeftToRight { get; set; }
    [Parameter] public EventCallback<IEnumerable<string>> MoveRightToLeft { get; set; }

    private List<string> selectedLeftIds = new();
    private List<string> selectedRightIds = new();
    private bool _handlersRegistered = false;
    private bool _previousShowState = false;
    private DotNetObjectReference<DualListMembershipModal>? _dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Only register/unregister handlers when Show state changes, not on every render
        if (_previousShowState != Show)
        {
            _previousShowState = Show;
            
            if (Show && !_handlersRegistered)
            {
                // Dispose previous reference if it exists
                if (_dotNetRef != null)
                {
                    _dotNetRef.Dispose();
                }
                
                // Create new DotNetObjectReference for this instance
                _dotNetRef = DotNetObjectReference.Create(this);
                
                // Always unregister first (defensive) before registering
                await JSRuntime.InvokeVoidAsync("selectUtils.unregisterDblClick", LeftSelectId);
                await JSRuntime.InvokeVoidAsync("selectUtils.unregisterDblClick", RightSelectId);
                
                // Register handlers
                await JSRuntime.InvokeVoidAsync("selectUtils.registerDblClick", LeftSelectId, _dotNetRef, nameof(OnLeftDblClick));
                await JSRuntime.InvokeVoidAsync("selectUtils.registerDblClick", RightSelectId, _dotNetRef, nameof(OnRightDblClick));
                
                _handlersRegistered = true;
            }
            else if (!Show && _handlersRegistered)
            {
                // Unregister handlers
                await JSRuntime.InvokeVoidAsync("selectUtils.unregisterDblClick", LeftSelectId);
                await JSRuntime.InvokeVoidAsync("selectUtils.unregisterDblClick", RightSelectId);
                
                // Dispose DotNetObjectReference
                if (_dotNetRef != null)
                {
                    _dotNetRef.Dispose();
                    _dotNetRef = null;
                }
                
                _handlersRegistered = false;
            }
        }
    }

    public void Dispose()
    {
        // Clean up when component is disposed
        if (_dotNetRef != null)
        {
            _dotNetRef.Dispose();
            _dotNetRef = null;
        }
    }

    private async Task OnLeftChange(ChangeEventArgs _)
    {
        var values = await JSRuntime.InvokeAsync<string[]>("selectUtils.getSelectedValues", LeftSelectId);
        selectedLeftIds = values?.ToList() ?? new List<string>();
        StateHasChanged();
    }

    private async Task OnRightChange(ChangeEventArgs _)
    {
        var values = await JSRuntime.InvokeAsync<string[]>("selectUtils.getSelectedValues", RightSelectId);
        selectedRightIds = values?.ToList() ?? new List<string>();
        StateHasChanged();
    }

    private async Task MoveLeftSelectionToRight()
    {
        if (selectedLeftIds.Any())
        {
            await MoveLeftToRight.InvokeAsync(selectedLeftIds.ToArray());
            selectedLeftIds.Clear();
            await JSRuntime.InvokeVoidAsync("selectUtils.clearSelection", LeftSelectId);
            StateHasChanged();
        }
    }

    private async Task MoveRightSelectionToLeft()
    {
        if (selectedRightIds.Any())
        {
            await MoveRightToLeft.InvokeAsync(selectedRightIds.ToArray());
            selectedRightIds.Clear();
            await JSRuntime.InvokeVoidAsync("selectUtils.clearSelection", RightSelectId);
            StateHasChanged();
        }
    }

    private Task OnCloseClicked() => Close.InvokeAsync();

    [JSInvokable] 
    public async Task OnLeftDblClick(string id) 
    {
        await MoveLeftToRight.InvokeAsync(new[] { id });
        // Clear selections since the item was moved
        selectedLeftIds.Clear();
        StateHasChanged();
    }

    [JSInvokable] 
    public async Task OnRightDblClick(string id) 
    {
        await MoveRightToLeft.InvokeAsync(new[] { id });
        // Clear selections since the item was moved
        selectedRightIds.Clear();
        StateHasChanged();
    }
}


